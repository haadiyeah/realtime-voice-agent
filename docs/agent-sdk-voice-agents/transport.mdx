---
title: Realtime Transport Layer
description: Learn about the different transport layers that can be used with Realtime Agents.
---
Realtime Transport Layer
Default transport layers
Connecting over WebRTC
The default transport layer uses WebRTC. Audio is recorded from the microphone and played back automatically.

To use your own media stream or audio element, provide an OpenAIRealtimeWebRTC instance when creating the session.

import { RealtimeAgent, RealtimeSession, OpenAIRealtimeWebRTC } from '@openai/agents/realtime';

const agent = new RealtimeAgent({
  name: 'Greeter',
  instructions: 'Greet the user with cheer and answer questions.',
});

async function main() {
  const transport = new OpenAIRealtimeWebRTC({
    mediaStream: await navigator.mediaDevices.getUserMedia({ audio: true }),
    audioElement: document.createElement('audio'),
  });

  const customSession = new RealtimeSession(agent, { transport });
}

Connecting over WebSocket
Pass transport: 'websocket' or an instance of OpenAIRealtimeWebSocket when creating the session to use a WebSocket connection instead of WebRTC. This works well for server-side use cases, for example building a phone agent with Twilio.

import { RealtimeAgent, RealtimeSession } from '@openai/agents/realtime';

const agent = new RealtimeAgent({
  name: 'Greeter',
  instructions: 'Greet the user with cheer and answer questions.',
});

const myRecordedArrayBuffer = new ArrayBuffer(0);

const wsSession = new RealtimeSession(agent, {
  transport: 'websocket',
  model: 'gpt-4o-realtime-preview-2025-06-03',
});
await wsSession.connect({ apiKey: process.env.OPENAI_API_KEY! });

wsSession.on('audio', (event) => {
  // event.data is a chunk of PCM16 audio
});

wsSession.sendAudio(myRecordedArrayBuffer);

Use any recording/playback library to handle the raw PCM16 audio bytes.

Building your own transport mechanism
If you want to use a different speech-to-speech API or have your own custom transport mechanism, you can create your own by implementing the RealtimeTransportLayer interface and emit the RealtimeTransportEventTypes events.

Interacting with the Realtime API more directly
If you want to use the OpenAI Realtime API but have more direct access to the Realtime API, you have two options:

Option 1 - Accessing the transport layer
If you still want to benefit from all of the capabilities of the RealtimeSession you can access your transport layer through session.transport.

The transport layer will emit every event it receives under the * event and you can send raw events using the sendEvent() method.

import { RealtimeAgent, RealtimeSession } from '@openai/agents/realtime';

const agent = new RealtimeAgent({
  name: 'Greeter',
  instructions: 'Greet the user with cheer and answer questions.',
});

const session = new RealtimeSession(agent, {
  model: 'gpt-4o-realtime-preview-2025-06-03',
});

session.transport.on('*', (event) => {
  // JSON parsed version of the event received on the connection
});

// Send any valid event as JSON. For example triggering a new response
session.transport.sendEvent({
  type: 'response.create',
  // ...
});

Option 2 — Only using the transport layer
If you don’t need automatic tool execution, guardrails, etc. you can also use the transport layer as a “thin” client that just manages connection and interruptions.

import { OpenAIRealtimeWebRTC } from '@openai/agents/realtime';

const client = new OpenAIRealtimeWebRTC();
const audioBuffer = new ArrayBuffer(0);

await client.connect({
  apiKey: '<api key>',
  model: 'gpt-4o-mini-realtime-preview',
  initialSessionConfig: {
    instructions: 'Speak like a pirate',
    voice: 'ash',
    modalities: ['text', 'audio'],
    inputAudioFormat: 'pcm16',
    outputAudioFormat: 'pcm16',
  },
});

// optionally for WebSockets
client.on('audio', (newAudio) => {});

client.sendAudio(audioBuffer);







---------------- realtime session (page content from: https://openai.github.io/openai-agents-python/ref/realtime/session/ ) ---------------------

RealtimeSession
Bases: RealtimeModelListener

A connection to a realtime model. It streams events from the model to you, and allows you to send messages and audio to the model.

Example

runner = RealtimeRunner(agent)
async with await runner.run() as session:
    # Send messages
    await session.send_message("Hello")
    await session.send_audio(audio_bytes)

    # Stream events
    async for event in session:
        if event.type == "audio":
            # Handle audio event
            pass
Source code in src/agents/realtime/session.py
model property

model: RealtimeModel
Access the underlying model for adding listeners or other direct interaction.

__init__

__init__(
    model: RealtimeModel,
    agent: RealtimeAgent,
    context: TContext | None,
    model_config: RealtimeModelConfig | None = None,
    run_config: RealtimeRunConfig | None = None,
) -> None
Initialize the session.

Parameters:

Name	Type	Description	Default
model	RealtimeModel	The model to use.	required
agent	RealtimeAgent	The current agent.	required
context	TContext | None	The context object.	required
model_config	RealtimeModelConfig | None	Model configuration.	None
run_config	RealtimeRunConfig | None	Runtime configuration including guardrails.	None
Source code in src/agents/realtime/session.py
__aenter__ async

__aenter__() -> RealtimeSession
Start the session by connecting to the model. After this, you will be able to stream events from the model and send messages and audio to the model.

Source code in src/agents/realtime/session.py

async def __aenter__(self) -> RealtimeSession:
    """Start the session by connecting to the model. After this, you will be able to stream
    events from the model and send messages and audio to the model.
    """
    # Add ourselves as a listener
    self._model.add_listener(self)

    model_config = self._model_config.copy()
    model_config["initial_model_settings"] = await self._get_updated_model_settings_from_agent(
        starting_settings=self._model_config.get("initial_model_settings", None),
        agent=self._current_agent,
    )

    # Connect to the model
    await self._model.connect(model_config)

    # Emit initial history update
    await self._put_event(
        RealtimeHistoryUpdated(
            history=self._history,
            info=self._event_info,
        )
    )

    return self
enter async

enter() -> RealtimeSession
Enter the async context manager. We strongly recommend using the async context manager pattern instead of this method. If you use this, you need to manually call close() when you are done.

Source code in src/agents/realtime/session.py
__aexit__ async

__aexit__(
    _exc_type: Any, _exc_val: Any, _exc_tb: Any
) -> None
End the session.

Source code in src/agents/realtime/session.py

async def __aexit__(self, _exc_type: Any, _exc_val: Any, _exc_tb: Any) -> None:
    """End the session."""
    await self.close()
__aiter__ async

__aiter__() -> AsyncIterator[RealtimeSessionEvent]
Iterate over events from the session.

Source code in src/agents/realtime/session.py

async def __aiter__(self) -> AsyncIterator[RealtimeSessionEvent]:
    """Iterate over events from the session."""
    while not self._closed:
        try:
            # Check if there's a stored exception to raise
            if self._stored_exception is not None:
                # Clean up resources before raising
                await self._cleanup()
                raise self._stored_exception

            event = await self._event_queue.get()
            yield event
        except asyncio.CancelledError:
            break
close async

close() -> None
Close the session.

Source code in src/agents/realtime/session.py

async def close(self) -> None:
    """Close the session."""
    await self._cleanup()
send_message async

send_message(message: RealtimeUserInput) -> None
Send a message to the model.

Source code in src/agents/realtime/session.py

async def send_message(self, message: RealtimeUserInput) -> None:
    """Send a message to the model."""
    await self._model.send_event(RealtimeModelSendUserInput(user_input=message))
send_audio async

send_audio(audio: bytes, *, commit: bool = False) -> None
Send a raw audio chunk to the model.

Source code in src/agents/realtime/session.py

async def send_audio(self, audio: bytes, *, commit: bool = False) -> None:
    """Send a raw audio chunk to the model."""
    await self._model.send_event(RealtimeModelSendAudio(audio=audio, commit=commit))
interrupt async

interrupt() -> None
Interrupt the model.

Source code in src/agents/realtime/session.py

async def interrupt(self) -> None:
    """Interrupt the model."""
    await self._model.send_event(RealtimeModelSendInterrupt())
update_agent async

update_agent(agent: RealtimeAgent) -> None
Update the active agent for this session and apply its settings to the model.

Source code in src/agents/realtime/session.py

async def update_agent(self, agent: RealtimeAgent) -> None:
    """Update the active agent for this session and apply its settings to the model."""
    self._current_agent = agent

    updated_settings = await self._get_updated_model_settings_from_agent(
        starting_settings=None,
        agent=self._current_agent,
    )

    await self._model.send_event(
        RealtimeModelSendSessionUpdate(session_settings=updated_settings)
    )